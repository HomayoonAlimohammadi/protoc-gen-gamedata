package gamedata

import (
	"encoding/json"
	"errors"
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

type Game struct {
	Fields     []Field
	CatToExtra map[string]Extra
}

type Extra struct {
	Name   string
	Fields []Field
}

type Field struct {
	Name string
	Type string
}

func Generate(p *protogen.Plugin) error {
	g := p.NewGeneratedFile("autogen/gamedata.go", "")
	g.P("// Code generated by gamedata. DO NOT EDIT")
	g.P("package gamedata")

	game, err := extract(p, g)
	if err != nil {
		return err
	}

	genHelpers(g, game)

	return nil
}

func extract(p *protogen.Plugin, g *protogen.GeneratedFile) (*Game, error) {
	for _, f := range p.Files {
		for _, m := range f.Messages {
			if m.Desc.Name() == "Game" {
				return extractGameData(m, g)
			}
		}
	}

	return nil, errors.New("failed to find `Game` message")
}

func extractGameData(m *protogen.Message, g *protogen.GeneratedFile) (*Game, error) {
	game := &Game{CatToExtra: make(map[string]Extra)}

	prefillCategories(m, game)

	for _, f := range m.Fields {
		if f.Desc.ContainingOneof() != nil && f.Desc.ContainingOneof().Name() == "extra" {
			err := fillExtras(g, f, game)
			if err != nil {
				return nil, fmt.Errorf("failed to fill extra: %w", err)
			}
		}

		game.Fields = append(
			game.Fields,
			Field{
				Name: string(f.Desc.Name()),
				Type: fieldGoType(g, f),
			},
		)
	}

	return game, nil
}

func prefillCategories(m *protogen.Message, game *Game) {
	for _, e := range m.Enums {
		if string(e.Desc.Name()) == "Category" {
			for _, v := range e.Values {
				if string(v.Desc.Name()) == "UNKNOWN" {
					continue
				}

				game.CatToExtra[string(v.Desc.Name())] = Extra{}
			}
		}
	}
}

func fillExtras(g *protogen.GeneratedFile, f *protogen.Field, game *Game) error {
	if !strings.HasSuffix(strings.ToLower(string(f.Desc.Name())), "_extra") {
		return fmt.Errorf("extra message %s does not end with _extra", strings.ToLower(string(f.Desc.Name())))
	}

	name := strings.TrimSuffix(strings.ToLower(string(f.Desc.Name())), "_extra")

	var fields []Field
	for _, innerf := range f.Message.Fields {
		fields = append(fields, Field{Name: string(innerf.Desc.Name()), Type: fieldGoType(g, innerf)})
	}

	_, ok := game.CatToExtra[strings.ToUpper(name)]
	if !ok {
		return fmt.Errorf("no category available for `%s`", strings.ToUpper(name))
	}

	game.CatToExtra[strings.ToUpper(name)] = Extra{
		Name:   string(f.Desc.Name()),
		Fields: fields,
	}

	return nil
}

func fieldGoType(g *protogen.GeneratedFile, field *protogen.Field) (goType string) {
	if field.Desc.IsWeak() {
		return "struct{}"
	}

	isPointer := field.Desc.HasPresence()
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		goType = "bool"
	case protoreflect.EnumKind:
		goType = g.QualifiedGoIdent(field.Enum.GoIdent)
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		goType = "int32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		goType = "int64"
	case protoreflect.FloatKind:
		goType = "float32"
	case protoreflect.DoubleKind:
		goType = "float64"
	case protoreflect.StringKind:
		goType = "string"
	case protoreflect.MessageKind, protoreflect.GroupKind:
		goType = "*" + g.QualifiedGoIdent(field.Message.GoIdent)
		isPointer = false
	}

	if isPointer {
		return "*" + goType
	}

	return goType
}

func genHelpers(g *protogen.GeneratedFile, game *Game) {
	b, err := json.MarshalIndent(game, "", "\t")
	if err == nil {
		g.P("/*", string(b), "*/")
	} else {
		g.P("/* failed to marshal to json */")
	}
}
